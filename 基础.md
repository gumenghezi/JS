### 1.内置类型
- 基本类型: null、undefined、boolean、number、string、symbol
- 引用类型: Object(深拷贝、浅拷贝的问题)
```javascript
function test(person) {
  person.age = 26
  person = {
    name: 'hzj',
    age: 18
  }
  return person
}
const p1 = {
  name: 'fyq',
  age: 19
}
const p2 = test(p1)
console.log(p1) // p1：{name: “fyq”, age: 26}
console.log(p2) // p2：{name: “hzj”, age: 18}

原因: 在函数传参的时候传递的是对象在堆中的内存地址值，test函数中的实参person是p1对象的内存地址，通过调用person.age = 26确实改变了p1的值，但随后person变成了另一块内存空间的地址，并且在最后将这另外一份内存空间的地址返回，赋给了p2。
```

###  2.Typeof

`typeof` 对于基本类型，除了 `null` 都可以显示正确的类型

```javascript
typeof 1 // 'number'
typeof '1' // 'string'
typeof undefined // 'undefined'
typeof true // 'boolean'
typeof Symbol() // 'symbol'
typeof b // b 没有声明，但是还会显示 undefined
```

`typeof `  对于对象，除了函数都会显示 `object`

```
typeof [] // 'object'
typeof {} // 'object'
typeof console.log // 'function'
```

对于 `null` 来说，虽然它是基本类型，但是会显示 `object`，这是一个存在很久了的 Bug，`000` 开头代表是对象，然而 `null` 表示为全零

```js
typeof null // 'object'
```

如果我们想获得一个变量的正确类型，可以通过 `Object.prototype.toString.call(xx)`。这样我们就可以获得类似 `[object Type]` 的字符串。



### 3.类型转换 

#### boolean

在条件判断时，除了 `undefined`， `null`， `false`， `NaN`， `''`， `0`， `-0`，其他所有值都转为 `true`，包括所有对象

#### 对象

对象在转换基本类型时，首先会调用 `valueOf` 然后调用 `toString`。并且这两个方法你是可以重写的。

```javascript
let b = {
    valueOf() {
      return 0;
    },
    toString() {
      return '1';
    },
    [Symbol.toPrimitive]() {
      return 2;
    }
}
console.log(1 + b) // => 3
console.log('1' + b) // => '12'
```

#### 四则运算符



